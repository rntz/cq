#!/bin/zsh

integer queuefd

# Kill our children when we receive a kill-signal.
abort() {
    echo 'abort called' >&2
    #pkill -P $$
    return $(( 128 + $1 ))
}

# Utility functions
die() { echo $@ >&2; exit 1 }

init() {
    # Determine the control directory.
    [ -n $CQDIR ] || die 'No CQDIR specified'
    [ -d $CQDIR ] || die 'CQDIR is not a directory'
    [ -x $CQDIR ] || die 'CQDIR not searchable'
    [ -w $CQDIR ] || die 'CQDIR not writable'

    # Open the queue file
    exec -- {queuefd}>>$CQDIR/queue
}

lock() { flock -x $queuefd }
unlock() { flock -u $queuefd }

# Commands
cq-new() {
    # Set up a new control directory.
    CQDIR=${1:-${CQDIR:-$(mktemp -d --tmpdir cq.XXXXXXXXXX)}}
    mkdir -p $CQDIR || die
    echo "export CQDIR='$CQDIR'"
}

cq-nop() {}

cq-run() {
    echo $$ > $CQDIR/run.pid
    #TRAPEXIT() { rm $CQDIR/run.pid }

    # We need to send inotifywait's output to an actual file rather than pipe it
    # to a subshell or a fifo because otherwise the fact that the queue blocks
    # messes it up. I hate synchronous IO.
    inotifywait -q -e modify -m $CQDIR --exclude modifylog | \
        grep --line-buffered 'MODIFY queue$' > $CQDIR/modifylog &

    # Wait for stuff to happen and dispatch on it
    inotail -n 0 -f $CQDIR/modifylog | while true; do
        while { lock
                [[ -s $CQDIR/queue ]] }
        do
            item=$(head -n 1 $CQDIR/queue)
            sed -i 1d $CQDIR/queue
            unlock

            if sh -c $item
            then echo "executed: $item"
            else echo "failed to execute: $item" >&2
            fi
        done

        unlock
        read line               # wait for inotail to tell us something changed
    done
}

cq-edit-queue() {
    lock

    tmpfile=$(mktemp)
    cp $CQDIR/queue $tmpfile

    if $EDITOR $tmpfile; then
        cp $tmpfile $CQDIR/queue
    else
        echo "editor failed, not modifying queue" >&2
        xyzzy=1
    fi

    echo removing temp file
    rm $tmpfile

    echo here unlocking
    unlock
    #flock -u $queuefd
    echo here unlocked

    echo "xyzzy: ${xyzzy:-0}"
    return ${xyzzy:-0}
}

cq-add() {}


# Determine command & global options and run command
while getopts 'd:' option ${@}; do
    case $option in
        d) CQDIR=$OPTARG;;
        *) echo "Unrecognized option flag ${option}"; exit 1;;
    esac
    set -- ${@[$OPTIND,-1]}
done

cmd=$1; shift

case $cmd in
    add|edit|edit-queue|halt|list|new|nop|run)
        # command was fully specified, do nothing
        ;;

    # Aliases go here.
    a) cmd=add;;
    e) cmd=edit;;
    eq) cmd=edit-queue;;
    h) cmd=halt;;
    l) cmd=list;;
    r) cmd=run;;

    *) echo "unrecognized command: $cmd"; exit 1;;
esac

[ $cmd != new ] && init
cq-$cmd $@
