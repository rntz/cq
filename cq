#!/bin/zsh
integer lockfd
exedir=$(dirname $(readlink -f $0))

# Utility functions
die() { echo fatal: $@ >&2; exit 1 }
warn() { echo warning: $@ >&2; return 1 }

init() {
    # Determine the instance directory.
    [[ -n $CQDIR ]] || die 'no CQDIR specified'
    [[ -d $CQDIR ]] || die 'CQDIR is not a directory'
    [[ -x $CQDIR ]] || die 'CQDIR not searchable'
    [[ -w $CQDIR ]] || die 'CQDIR not writable'

    # Open the queue file
    exec {lockfd}>$CQDIR/lock
}

cqd-running() {
    cqdpid=$(cat $CQDIR/cqd.pid 2>/dev/null) && \
        {[[ -n $cqdpid ]] || warn 'cqd.pid exists but is empty'}
}

lock() { flock -x $lockfd }
unlock() { flock -u $lockfd }

notify-cqd() {
    cqd-running && kill -USR1 $cqdpid
}

newjobid() {
    comm -13 <(ls $CQDIR/jobs | egrep '^[0-9]+$' | sort -n) \
             <(for ((i=0; ; ++i)) echo $i) \
        2>/dev/null | head -1 2>/dev/null
}

jobsummary() {
    local jobdir=$1
    local desc="$(head -n 2 $jobdir/run | tail -n 1)"
    (( $(wc -l < ${jobdir}/run) > 2 )) && desc+='...'
    echo $desc
}

jobdesc() {
    local jobid=$1
    local jobdir=${2-$CQDIR/jobs/$jobid}
    local jobfd
    exec {jobfd}>$jobdir/lock
    flock -s $jobfd

    echo "${jobid}\t$(jobsummary $jobdir)"

    # not sure unlocking is necessary, since we're closing the fd anyway
    flock -u $jobfd
    exec {jobfd}>&-
}

jobdescs() { while read jobid; do jobdesc $jobid; done }

# Commands
cq-create() {
    # N.B: This function is idempotent - if run when CQDIR is already an
    # instance directory, it will do nothing (aside from changing a few
    # timestamps). Try to keep it that way.

    # Set up a new instance directory.
    CQDIR=${1-${CQDIR-$(mktemp -d --tmpdir cq.XXXXXXXXXX)}}
    mkdir -p $CQDIR || die "cannot make instance directory"
    mkdir -p $CQDIR/jobs || die "cannot make job directory"
    touch $CQDIR/queue || die "cannot make job queue"

    echo "export CQDIR='$CQDIR'"
}

cq-destroy() {
    CQDIR=${1-${CQDIR}}
    [[ -f $CQDIR/cqd.pid ]] && die 'cqd still running'
    rm -r $CQDIR
    echo "unset CQDIR"
}

cq-hup() {
    notify-cqd || { echo "cqd not running" >&2; return 1 }
}

cq-start() {
    # FIXME: avoid starting cqd more than once
    export CQDIR
    $exedir/cqd $@ >$CQDIR/log 2>&1 &
    echo $! > $CQDIR/cqd.pid
}

cq-stop() {
    while getopts ':f' option $@; do
        case $option in
            f) force=true;;
            *) die "unrecognized cq-stop option: -${OPTARG}";;
        esac
    done
    set -- ${@[$OPTIND,-1]}

    cqd-running || die 'cqd is not running'

    if [[ -d /proc/$cqdpid ]]; then
        if ${force-false}
        then
            kill $cqdpid || die 'could not kill cqd'
            rm -f $CQDIR/cqd.pid
            if [[ -d $CQDIR/current ]]; then rm -r $CQDIR/current; fi
        else
            kill -USR2 $cqdpid || die 'could not signal cqd'
            if [[ -f $CQDIR/cqd.pid ]] && [[ -d $CQDIR/current ]]; then
                echo 'cqd will exit after it finishes its current job.'
                echo 'To kill it immediately, use `cq stop -f`.'
            fi
        fi
    else
        echo 'cqd does not appear to be running, removing cqd.pid'
        rm $CQDIR/cqd.pid
    fi
}

cq-status() {
    echo "CQDIR is $CQDIR"
    lock

    if cqd-running; then
        if [[ -d /proc/$cqdpid ]]
        then echo "cqd is running with pid $cqdpid"
        else echo "cqd ostensibly has pid $cqdpid, but is not running!"
        fi
    else echo "cqd is not running"
    fi

    [[ -d $CQDIR/current ]] && echo "current job: $(jobsummary $CQDIR/current)"

    unlock
}

cq-view() {
    # No locking can save the fundamental issue here - the current job can end
    # at any time. So we don't do any locking.

    [[ -f $CQDIR/current/pid ]] || die "no current job to view"
    local pid=$(cat $CQDIR/current/pid)
    screen -r $pid
}

cq-list() {
    tmp=$(mktemp)
    lock

    # Determine which jobs aren't in the queue file
    comm -23 <(ls $CQDIR/jobs | sort -n) <(sort -n $CQDIR/queue) > $tmp

    {
        echo 'JOBID\tSUMMARY'
        # Current job.
        [[ -d $CQDIR/current ]] && jobdesc '*' $CQDIR/current
        # Jobs in the queue.
        cat $CQDIR/queue | jobdescs
        # Jobs not in the queue, if any exist.
        [[ -s $tmp ]] && { echo '--'; jobdescs < $tmp }
    } | column -s $'\t' -t

    unlock
    rm $tmp
}

cq-edit() {
    jobid=$1
    [[ -n $jobid ]] || die "no jobid supplied"
    jobdir=$CQDIR/jobs/$jobid
    flock -x $jobdir/lock $EDITOR $jobdir/run
}

cq-edit-queue() {
    flock -x $CQDIR/lock $EDITOR $CQDIR/queue
    notify-cqd
}

cq-add() {
    # Parse options.
    while getopts ':en:' option ${@}; do
        case $option in
            e) edit=true;;
            n) jobid=$OPTARG;;
            *) die "unrecognized cq-add option: -${OPTARG}";;
        esac
    done
    set -- ${@[$OPTIND,-1]}

    lock

    # Create a directory for our job.
    [[ -z $jobid ]] && jobid=$(newjobid)
    jobdir=$CQDIR/jobs/$jobid
    mkdir $jobdir 2>/dev/null || die "job already exists: $jobid"
    # lock handoff to avoid exposing our job directory in an uninitialized state
    exec {jobfd}>$jobdir/lock
    flock -x $jobfd
    unlock

    # Initialize our job's directory.
    runfile=$jobdir/run
    cat >$runfile <<EOF
#!/bin/sh
$@
EOF
    (( $? )) && die "failed to create job runfile"
    chmod +x $runfile || die "cannot make job runfile executable"

    # Edit the job if the user requested it.
    if [[ -n $edit ]] && ! $EDITOR $runfile; then
        echo "editor failed, removing job $jobid" >&2
        lock
        rm -r $jobdir || echo "could not remove job $jobid" >&2
        exit 1
    fi

    # Unlock job's directory.
    flock -u $jobfd
    exec {jobfd}>&-

    # Add to queue.
    lock
    echo $jobid >> $CQDIR/queue
    notify-cqd
    unlock
}

cq-remove() {
    lock

    jobid=$1
    jobdir=$CQDIR/jobs/$jobid
    [[ -d $jobdir ]] || die "no such job: ${jobid}"

    # Remove from queue
    tmp=$(mktemp)
    cp $CQDIR/queue $tmp
    fgrep -x -v $jobid $tmp > $CQDIR/queue
    notify-cqd

    rm -r $jobdir || {
        echo "Cannot remove job dir for ${jobid}"
        echo "Attempting to restore job queue..."
        if cp $tmp $CQDIR/queue
        then echo "Job queue restored."
        else echo 'Could not restore job queue!'
        fi
        exit 1
    } >&2

    unlock
}


# Determine command & global options and run command
while getopts ':d:' option ${@}; do
    case $option in
        d) CQDIR=$OPTARG;;
        *) die "unrecognized option: -${OPTARG}";;
    esac
    set -- ${@[$OPTIND,-1]}
done

(( $# )) || die 'no command supplied'
cmd=$1; shift

case $cmd in
    add|create|destroy|edit|edit-queue|hup|list|remove|start|status|stop|view)
        # command was fully specified, do nothing
        ;;

    # Aliases go here.
    a) cmd=add;;
    e) cmd=edit;;
    eq) cmd=edit-queue;;
    l) cmd=list;;
    r) cmd=remove;;
    s) cmd=status;;
    v) cmd=view;;

    *) echo "unrecognized command: $cmd"; exit 1;;
esac

[[ $cmd != create ]] && init
cq-$cmd $@
